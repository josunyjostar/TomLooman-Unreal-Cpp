DefaultsOnly - 블루프린트 에디터에서만 이라는뜻

라이더 - 쉬프트 + 알트  + O 
라이더 - 컨트롤 + D
라이더 - 컨트롤 + 쉬프트 + K

언리얼 - 쉬프트 + F1 (실행하고 마우스 컨트롤 획득)
언리얼 - 컨트롤 + P (오픈에셋)
언리얼 - 컨트롤 + 스페이스 (컨텐츠 브라우저)
Win + Ctrl + L 

Tool -> Visual Logger

~ 누르고 show collision 
TAutoConsoleVariable<>
' 누르면 게임 디버그  (AI의 경우 해당 AI가 근처에 잇거나 선택해야 뜸)

에디터 실행 화면 옆 점3개 - 시뮬레이트 
F2 unlit mode 
F3 lit view mode 

Control Rotation 을 캐릭터랑 스프링암 모두 가지고 있음

Camera Settings
Use Pawn Control Rotation - 스프링암이 캐릭터의 컨트롤 회전에 따라 회전

캐릭터 - Use Controller Rotation Yaw = true 
캐릭터가 PlayerController의 좌우 회전(Yaw)을 따라 회전 

--------------------------------------

should bounce  - projectile movement 
hidden in game 

프로젝트 설정 - 콜리전 - 프리셋 : 이 습관을 들이도록

콜리전 트레이스 타입 - visibility  : 그냥 채널 이름임


에셋 등록시는 항상 블루프린트에서하고 c++에서 안한다고함 (이득우랑 반대)

생성자에서 뭐 수정하면 에디터 끄고해야 적용됨 CDO

생성자에서 델리게이트 할당하지마 지옥이 될수잇음
PostInitializeComponents 에서 해

충돌체에 붙어잇는 델리게이트
onComponentOverlap
onComponentHit
 
Sparse Delegate - 바인딩된 경우에만 힙에 메모리 할당/바인딩 안 하면 메모리 0

NiagaraSystem은 여러 에미터를 가짐
UNiagaraComponent 는 액터에 붙이는 용도 

컨트롤러는 게임 내내 존재 이펙트처럼 없어지지 않음

TSubclassOf: 클래스 타입 저장 (설계도)
TObjectPtr: 인스턴스 저장 (실제 생성된 객체)

스켈레톤에 소켓 추가하고 그 위치 받아오는거 배움

UCLASS(abstract) 이거 배움 블루프린트 마크업 안하는거

Instigator 어떤 행동을 시작한 주체(원인 제공자)
발사한 주체의 충돌은 무시하는법 SphereComponent->IgnoreActorWhenMoving(GetInstigator(),true);

--------------------------------------
에셋 할당은 C++ 대신 항상 블루프린트에서 수행한다는 점을 기억

틸트 = slomo 0.2
슬롯은 그냥 애니몽타주가 플레이 되는 곳 : 원래 애니메이션 → 몽타주로 전환 (그냥 애니메이션 스위칭임)

이펙스 생성
UNiagaraFunctionLibrary::SpawnSystemAtLocation

Damage Type 블루프린트에서 impulse 설정
simulate physics : 디테일 패널
can be damaged : 디테일 패널 

input 트리거 설정은 input action에서 하는거임

언리얼에서 c++ 클래스 생성 잘 안되면 플러그인 visual studio 2022 인테그레이션 문제임
대신 Rider 에디터에서 붉은색으로 보이는 문제가 있음

URadialForceComponent 특정 지점을 중심으로 방사형 물리력을 가하는 컴포넌트

c++ 에서 SetSimulatePhysics 설정하면 반드시 SetCollisionProfileName 도 설정해주어야함


--------------------------------------

PrimaryActorTick.bStartWithTickEnabled = false;
게임이 시작되거나 액터가 스폰될 때, Tick() 함수가 자동으로 실행되지 않도록 설정

virtual void SetupInputComponent() override; 입력 바인딩 하는곳, 컨트롤러
SetupPlayerInputComponent : 입력 바인딩 하는곳 , 플레이어 

언리얼 - 컨트롤 + 쉬프트 + S : 모든 변경 사항 저장


Engine  - Collision - Profile 에서
Trace Type은 Collision queries 만 가능 
CollisionEnabled : Query: Overlap/Trace 검사 가능 , Physics: 실제 물리 충돌 발생 (Block 적용)

Trace 채널 만들고 Interaction
LidMeshComponent->SetCollisionProfileName("Interaction");
하면 원하는것만 상호작용 가능 


- BlueprintNativeEvent: C++이 기본, BP가 오버라이드 가능
- BlueprintImplementableEvent: BP에서만 구현 (C++ 본체 없음)

UFUNCTION(BlueprintNativeEvent)
void Interact();
로 인터페이스를 블루프린트 노출시키면 반드시 Interface 상속하는 클래스의 함수는
인터페이스에서 명명한 함수명_Implementation 이름으로 구현해야하고
블루프린트에서 해당 함수를 이벤트 그래프에서 만들고 parent 호출도 해야함
그리고 호출 시 직접 호출이 아니라 IRogueInteractionInterface::Execute_명명한 함수이름

Level Blueprint 
해당 레벨에 배치된 액터들을 직접 레퍼런스로 잡아서 스크립팅할 수 있음

--------------------------------------
[ 레벨 블루프린트에서 인터페이스 이벤트로 액터끼리 연결하는 흐름]
* 레벨 BP가 중간 다리 역할로, 개별 BP끼리 직접 참조 없이 인터페이스를 통해 느슨하게 연결하는 방식
레벨 BP에서는 일일이 레퍼런스 잡아야 함

1. BP 클래스에 인터페이스 추가                                                                                                                                                                    
  - 블루프린트 → Class Settings → Interfaces에서 인터페이스 추가
  - 이벤트 그래프에서 해당 인터페이스 이벤트 구현

2. 레벨 BP에서 인스턴스 레퍼런스 생성 + 이벤트 연결
  - Open Level Blueprint
  - 뷰포트에서 원하는 인스턴스 선택 → 우클릭 → Create a Reference to (액터)
  - 그 레퍼런스에서 인터페이스 이벤트를 호출하도록 연결
  - 이렇게 하면 레벨에 배치된 특정 인스턴스와 인터페이스 이벤트가 바인딩됨

3. 트리거 대상 연결
  - 이벤트 발생 시 작동시킬 액터도 뷰포트에서 선택 → 레퍼런스 만들어서 연결

*Spatially Loaded - 월드 파티션 관련 내용 
서로 상호작용 하는 물체가 멀리 떨어져잇으면 이거 off 하라는거

--------------------------------------

[ 블루프린트 커스텀 함수를 통한 BP 간 통신 ]
* 인터페이스 없이, BP 자체에 함수를 만들어 레벨 BP에서 직접 호출하는 방식

1. BP 클래스 생성 및 기능 구현
  - Pawn 등 원하는 부모 클래스를 상속한 블루프린트 생성 (예: BP_ProjectileSpammer)
  - Class Defaults에서 Tick Interval 설정으로 Tick 주기 조절 가능
  - 이벤트 그래프에서 Spawn Actor 등으로 핵심 로직 구현
    - Instigator를 Self로 설정하여 스폰 주체 명시

2. 커스텀 함수 생성
  - Functions 섹션 → + 버튼으로 함수 추가 (예: StartSpawning)
  - 함수 내부에서 타이머 시작, 변수 세팅 등 외부에서 트리거할 로직 작성

3. 레벨 BP에서 호출
  - 뷰포트에서 배치된 BP 인스턴스 선택 → 레벨 BP에 레퍼런스 생성
  - 해당 레퍼런스에서 커스텀 함수(StartSpawning)를 직접 호출

* 인터페이스 방식과의 차이
  - 인터페이스: 여러 클래스가 동일한 함수명으로 각자 다르게 구현 (다형성, 느슨한 결합)
  - 커스텀 함수: 특정 BP 타입에 종속된 함수를 직접 호출 (단순하고 직관적)
--------------------------------------

강의 11 - 행동 트리 정리

1. AI 컨트롤러 설정
 - AI 컨트롤러에 행동트리 연결
 - AI에 컨트롤러 할당 시 C++ 클래스가 아닌 블루프린트 클래스를 할당할 것 (C++ 클래스에는 행동트리 에셋이 할당 안 됨)

2. 네비메쉬
 - AI는 네비메쉬 없으면 동작 안 함
 - 시각화 단축키: P
 - Modeling Tools Editor Mode 플러그인 활성화 필요
 - 월드 물체가 네비메쉬 방해 시: Can Ever Affect Navigation 확인

3. 행동 트리 노드
 - 시퀀스 - 좌→우 순서 실행
 - 셀렉터 - 실행 가능한 노드 탐색
 - 서비스 - 자식 노드 활성화 중 특정 간격으로 반복 실행

*성능 주의
 - Line Trace / 충돌 쿼리 - 둘 다 블로킹 동작 (게임 스레드 멈춤)


TaskNode - 행동트리에 없는거 커스텀으로 만드는거


Sequence (시퀀스)

우선순위대로 실행
하나라도 실패하면 중단 (AND 로직)
모두 성공해야 Success

Selector (셀렉터)

우선순위대로 실행
하나라도 성공하면 중단 (OR 로직)
모두 실패해야 Failure

Decorator (데코레이터)

노드의 실행 조건 설정
성공/실패 판정 변경 가능
실행 중 감시 및 중단

Observer Aborts: Lower Priority
- 데코레이터가 붙은 노드보다 우선순위가 낮은(오른쪽에 있는) 노드들이 실행 중일 때, 조건 변화 시 그것들을 중단시키는 옵션

-------------------

=== EQS (Environment Query System) ===

행동트리에서 EQS노드 만들고 BP_EnvirentQuery 연결 (기준점은 c++ 커스텀)

[구성 요소]
- Generator : 평가할 후보 포인트(아이템)들을 생성
- Context   : 쿼리의 기준점 (누구 기준으로 평가할지)
- Test      : 각 후보 포인트를 필터링/점수 매기기

[Test Purpose]
- Filter Only      : 조건 불만족 아이템 제거만 (점수 X)
- Score Only       : 점수만 부여 (제거 X)
- Filter and Score : 필터링 + 점수 부여 둘 다 수행

[EnvQueryTest_Trace]
- 라인 트레이스로 시야 차단 여부를 판단하는 테스트
- Bool Match = True  → 시야가 차단된 후보만 통과 (엄폐물 뒤 찾기 등)
- Bool Match = False → 시야가 차단되지 않은 후보만 통과 (직접 보이는 위치)

[커스텀 Context - RogueEnvQueryContext_TargetActor] : EQS 시스템의 평가 기준점
- 기본 Querier는 AI 자신이 기준점
- 공격 대상(플레이어) 기준으로 평가하려면 커스텀 Context 필요
- 블랙보드의 TargetActor를 기준점으로 제공

[BTTask_RunEQSQuery - BlackboardKey]
- EQS 결과(최적 위치)를 블랙보드에 저장할 키를 지정
- 흐름: EQS 실행 → 최적 위치 선정 → BlackboardKey에 저장 → MoveTo가 읽어서 이동


-------------------

언리얼 규칙

[1] NewObject
----------------------------------------------
- AActor를 상속받지 않은 일반 UObject 클래스의
  인스턴스를 생성할 때 사용
- AActor 상속 클래스는 SpawnActor 사용


[2] BlueprintNativeEvent
----------------------------------------------
- C++ 기본 구현 제공 + BP에서 선택적 오버라이드

  부모 클래스:
    헤더  -> UFUNCTION(BlueprintNativeEvent)
             void 함수명();
    cpp   -> void UClass::함수명_Implementation() { ... }

  자식 클래스 (C++ 오버라이드):
    헤더  -> virtual void 함수명_Implementation() override;
    cpp   -> void UChildClass::함수명_Implementation() { ... }

  호출은 _Implementation 붙이지 않고 호출

  실행 우선순위:
    BP 오버라이드 -> C++ _Implementation

  주의:
    BP에서 Super/Parent 호출 안 하면
    원래 C++ 구현은 건너뜀


[3] BlueprintImplementableEvent
----------------------------------------------
- C++ 구현 없음, BP에서만 구현
- C++에서 선언만 하고 .cpp에서 구현하지 않음


블루프린트 Pure Function 매번 다시 실행됨 

해결법 3가지 
1. 결과를 변수에 저장해서 재사용
2. 노드 우클릭 → exec pin 활성화 (순수 함수 해제) : exec 체인에 연결해야 의미있음
3. 블루프린트 노출 시킬 함수가 비싼 함수면 BlueprintPure 키워드 붙이지 말것 

